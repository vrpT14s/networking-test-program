Thu Feb 22 05:54:48 PM GMT 2024
I already wrote the tcp connection code before, it's not much but there are some specific details about using getaddrinfo etc., or that you have to remember to start a socket as IPv6 then turn off the IPv6 option (or maybe it's turned off by default usually and I only did that as a precaution, I don't remember, I should write more comments), things like that is why I'm reusing it. I feel like the request_t and reply_t structs are a bit confusing because they have the exact same innards, but I don't think I should sweat it too much.

Okay, then my ideas about the structures. I just need to add a wrapper around send or reply to encrypt things? Almost. The problem is authentication. Like my book said I'll be authenticating then encrypting, because it does feel like Eve can do weird things with the MAC code and take advantage of the fact that there are a lot more collisions, compared to encryption where there are no collisions of course, since it's a bijection. I also understand encryption better than the MAC stuff, I confess. So there is the idea of a message from Alice, which we then run through the MAC function (which is similar to and sometimes a hash, I forgot the slight difference). I'll hold the whole message in memory at least at the start but I can get away with only having a fixed block size buffer, which might be a maximum of 512 bits = 16 bytes. It wouldn't work if I were using SHA-1 or 2 because of those length extension attack things you can do, which seems like a rather large issue to me. SHA-3 is iterative but apparently doesn't suffer that, at least as long as you already have the message length at the beginning, which makes sense. If you have the message length from the start then you could just do SHA(message_length || message). This takes advantage of the one-directionality of the length extension: you can add at the end but not at the beginning. I am quite sure this isn't secure for some other reason though, since I haven't heard about it.

So here is the current plan: I somehow have the full message in memory and pass the pointer to my send function. Then I'll produce my MAC and append that at the end and encrypt the whole, maybe in place depending on whether I don't need the message anymore. Finally I just send that message on tcp, the whole thing at once. To receive, I take the encrypted message into memory, unencrypt then check the MAC and strip it and the padding, and finally pass it back to the user application. They'll free it later.
